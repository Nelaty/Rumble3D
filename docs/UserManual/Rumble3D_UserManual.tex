\documentclass[12p, paper=a4, leqno, colorinlistoftodos]{article}
\usepackage{wrapfig}
\usepackage[utf8]{inputenc}
\usepackage[ngerman]{babel}
\usepackage{amsmath}
\usepackage{amsfonts} 
\usepackage{amssymb}
\usepackage{enumerate}
\usepackage{graphicx}
\usepackage{wrapfig}

\usepackage[parfill]{parskip}
\usepackage{subcaption}
\usepackage{fix-cm}
\usepackage{transparent}
\usepackage{color}
\usepackage[table]{xcolor}
\usepackage{tocloft, url}
\usepackage{hyperref}
\usepackage{etoolbox}
\usepackage{fancyhdr}
\usepackage[german]{fancyref}
\usepackage{lipsum}	
\usepackage{sectsty}
\usepackage{pdfpages}
\usepackage{tcolorbox}
\usepackage{todonotes}

\usepackage{enumitem}
\usepackage[bottom]{footmisc}

\usepackage{forest}
\usepackage{float}
\usepackage{longtable}
\usepackage[normalem]{ulem}
\usepackage{multirow}
\usepackage[font=small,labelfont=bf,tableposition=top]{caption}

\usepackage{tikz}
\usetikzlibrary{positioning,automata}

\usepackage{calc}
\usepackage{geometry}
\usepackage{listings,lstautogobble}
\usepackage{algorithm}
\usepackage{algorithmicx}
\usepackage[noend]{algpseudocode}

\usepackage{array}
\usepackage{booktabs}
\usepackage{xcolor,colortbl}
\usepackage{setspace}
\usepackage{titlesec}
\usepackage[nottoc,notlot,notlof,numbib]{tocbibind}

\usepackage{cite}


\hypersetup{
	colorlinks,
	linkcolor={black},
	citecolor={blue!50!black},
	urlcolor={blue!80!black}	
}

% BEGIN COLORS
\definecolor{CBlue}{RGB}{1,0,119}
\definecolor{CBlack}{rgb}{0.0,0.0,0.0}
\definecolor{CLightGrey}{rgb}{0.664,0.664,0.664}
\definecolor{LightOrange}{rgb}{1.0,0.9,0.63}
\definecolor{DarkOrange}{rgb}{1.0,0.8,0.22}
\definecolor{LightCyan}{rgb}{1.0,0.9,0.63}
\definecolor{CWhite}{RGB}{0,0,0}
\definecolor{CLink}{rgb}{0.5,0.0,0.0}

\newcommand{\CTitle}{CBlue}
% BEGIN Table row/column colors{102,217,239}
\definecolor{CEven0}{RGB}{208,238,244}
\definecolor{CUneven0}{RGB}{255,255,255}
\definecolor{CEven1}{rgb}{1.0,1.0,1.0}
\definecolor{CUneven1}{rgb}{1.0,1.0,1.0}
% END Table row/column colors
% END COLORS


% BEGIN NEWENVIRONMENTS
\newenvironment{packed_itemize}
{\begin{itemize}
		\setlength{\itemsep}{0pt}
		\setlength{\parskip}{0pt}
		\setlength{\parsep}{0pt}
	}{\end{itemize}}

\newenvironment{packed_description}
{\begin{description}
		\setlength{\itemsep}{0pt}
		\setlength{\parskip}{0pt}
		\setlength{\parsep}{0pt}}
	{\end{description}}

\newenvironment{packed_enumerate}
{\begin{enumerate}
		\setlength{\itemsep}{0pt}
		\setlength{\parskip}{0pt}
		\setlength{\parsep}{0pt}
	}{\end{enumerate}}

% END NEWENVIRONMENTS


% BEGIN NEWCOMMANDS
% tables
\newcommand{\tabularPaddingSmall}{\renewcommand{\arraystretch}{0.75}}
\newcommand{\tabularPaddingDefault}{\renewcommand{\arraystretch}{1}}
\newcommand{\tabularPaddinglarge}{\renewcommand{\arraystretch}{1.25}}
\newcommand{\tabularPaddingLarge}{\renewcommand{\arraystretch}{1.5}}
\newcommand{\tabularPaddingLARGE}{\renewcommand{\arraystretch}{2}}
\newcommand{\tabularPaddingBot}{\vspace{0.5cm}}

\newcommand{\tabitem}{~~\llap{\textbullet}~~}
\newcommand{\coloredHline}[1]{\arrayrulecolor{#1}\hline}
\newcommand{\minitab}[2][l]{\begin{tabular}{#1}#2\end{tabular}}

% quoting
\newcommand{\quoteSource}[2]{\glqq{#1}\grqq, \textit{#2}}
\newcommand{\quoteQuick}[1]{\glqq{#1}\grqq}
\newcommand{\quoteAuthor}[2]{\quoteQuick{#1}, von \textit{#2}}
\newcommand{\quoteCite}[2]{\quoteQuick{\textit{#1}}#2}
\newcommand{\srcSelf}{\\\text{Quelle: Eigene Darstellung}}
\newcommand{\citePage}[2]{\cite{#1} Seite: {#2}}
\newcommand{\citeEquation}[1]{\text{\hspace{1cm}{#1}}}

% paragraphs
\newcommand{\parTiny}{\vspace{2mm}\\}
\newcommand{\parSmall}{\\~\par}
\newcommand{\parNoIndent}{\\\noindent}
\newcommand{\parWrapfig}{\\\text{ }\\}

% math


% 
\newcommand{\emphFold}[1]{\textbf{#1}}

% page layout
\newcommand{\geometryNormal}{\newgeometry{top = 2cm, left=2.5cm,bottom=2cm, right = 4cm}}
\newcommand{\geometryToc}{\newgeometry{top = 3cm, left=3cm,bottom=3cm, right = 3cm}}

% todo notes
\newcommand{\todoLowp}[1]{\todo[color=green!40]{#1}}
\newcommand{\todoMedp}[1]{\todo[color=orange!40]{#1}}
\newcommand{\todoHighp}[1]{\todo[color=red!40]{#1}}
\newcommand{\todoFig}[1]{\missingfigure{#1}}

% titles
\colorlet{ctcolorchapternum}{black}

\newcommand\mysectionformatCore[1]{%
	\vspace{-3em}\parbox[b]{\dimexpr\textwidth-1em\relax}{\raggedright#1}}
\newcommand{\titleformatCore}
{
	\titleformat
	{\section}[display]%
	{\color{black}\Large\bfseries}%
	{\vspace{-18em}\raggedleft{%
			{\color{ctcolorchapternum}\fontsize{60}{60}{\selectfont\thesection}}%
		}\hspace{1em}%
	}%
	{0pt}%
	{\mysectionformatCore}%
	[{\vspace{-0.5em}%
		\rule{0.75\textwidth}{1pt}%
		\rule[-3pt]{0.25\textwidth}{4pt}}]
	
	\titleformat
	{\subsection}[block]%
	{\color{black}\large\bfseries}%
	{\thesubsection\text{ }}%
	{0pt}{}[]%
	
	\titleformat
	{\subsubsection}[block]%
	{\color{black}\normalsize\bfseries}%
	{\thesubsubsection\text{ }}%
	{0pt}{}[]%
	
	\titleformat{\paragraph}
	{\normalfont\normalsize\bfseries}{\theparagraph}{1em}{}
	\titlespacing*{\paragraph}
	{0pt}{3.25ex plus 1ex minus .2ex}{1.5ex plus .2ex}
}

\newcommand\mysectionformatAppendix[1]{#1}
\newcommand{\titleformatAppendix}
{
	\titleformat
	{\section}[display]%
	{\color{black}\Large\bfseries}%
	{}{0pt}{\mysectionformatAppendix}[]
}

% END NEWCOMMANDS

% BEGIN RENEW COMMANDS
% END RENEW COMMANDS

\newlistof{links}{lks}{List of Links}
\newcommand\externallink[1]{%
	\refstepcounter{links}%
	\footnote{\url{#1}}%
	\addcontentsline{lks}{links}{%
		\protect\numberline{\thelinks}%
		\protect\url{#1}}%
}
\newcommand\externallinkIL[1]{%
	\refstepcounter{links}%
	\addcontentsline{lks}{links}{%
		\protect\numberline{\thelinks}%
		\protect\url{#1}}%
}

\newcolumntype{L}[1]{>{\raggedleft\let\newline\\\arraybackslash\hspace{0pt}}m{#1}}
\newcolumntype{R}[1]{>{\raggedright\let\newline\\\arraybackslash\hspace{0pt}}m{#1}}
%\newcolumntype{C}[1]{>{\raggedcenter\let\newline\\\arraybackslash\hspace{0pt}}m{#1}}

\newcolumntype{C}[1]{>{\raggedcenter\hspace{0pt}}p{#1}}


\author{Matthias Elmar Gensheimer}
\title{Rumble3D Manual}
\date{\today}


% BEGIN HEADER
\newcommand{\headerNormal}
{
	\pagestyle{fancy}
	\fancyhf{}
	\lhead{\rightmark}
	\rhead{\thepage}
}

\newcommand{\headerEmpty}
{
	\fancyhf{}
	\renewcommand{\headrulewidth}{0pt}
	\lhead{}
	\rhead{}
}

\newcommand{\headerErklaerung}
{
	\pagestyle{fancy}
	\fancyhf{}
	\rhead{\thepage}
}
% END HEADER

% BEGIN FOOTER
\usepackage{scrlayer}
\DeclareNewLayer[
foreground,
foot,
hoffset=0pt,
width=\paperwidth,
contents={\parbox{\layerwidth}{\centering}}
]{PageMarkCentredToPage}
\RedeclarePageStyleByLayers{plain}{PageMarkCentredToPage}
% END FOOTER

% BEGIN TOC SETUP
\makeatletter
\patchcmd{\l@section}
{\hfil}
{\leaders\hbox{\normalfont$\m@th\mkern \@dotsep mu\hbox{.}\mkern \@dotsep mu$}\hfill}
{}{}
\makeatother
% END TOC SETUP

% BEGIN PAGE SETUP
\geometryNormal
\setlength{\extrarowheight}{3pt}
% END PAGE SETUP


\titleformatCore
\headerNormal

\begin{document}
	\pagenumbering{Roman} 
	
	\lstset{language=C++,
		keywordstyle=\color{blue},
		basicstyle=\ttfamily,
		commentstyle=\ttfamily\itshape\color{gray},
		stringstyle=\ttfamily,
		showstringspaces=false,
		numbers=left,
		numberstyle=\small,
		breaklines=true,
		frameround=ffff,
		rulecolor=\color{black},
		frame=single,
		captionpos=b,
		autogobble=true
	}
	
	\begin{titlepage}
		\begin{flushright}
			\includegraphics[width=0.45\textwidth]{resources/hs_kempten_logo}
		\end{flushright}
		\begin{center}
			\topskip0pt
			\vspace*{\fill}
			\LARGE\textbf{Rumble3D User Manual}\\		
			\LARGE{A 3D physics library}\\

			\vfill
			\Large{\textcopyright 2018 Matthias Gensheimer}\\
			\Large{All Rights Reserved.}
		\end{center}
		
	\end{titlepage}
	
	% Add an empty page
	\mbox{}
	\thispagestyle{empty}
	\newpage
	
	\pagebreak
	
	\geometryNormal
	\tableofcontents
	\geometryNormal
	\setstretch{1.30}
	
	\pagenumbering{arabic} 
	\section{Introduction}
	Rumble3D is a 3D physics library. Its core features are:
	\begin{itemize}
		\item Particle simulation
		\item Rigid body simulation
		\item Force generators
		\item Collision detection and resolution
	\end{itemize}
	Due to the engine being made up of physic modules, it is fully extensible.

	This manual will guide you through your first steps setting up the physics engine. It will explain the main parts of using the particle and rigid body engine aswell as the collision detection and resolution pipeline used in the rigid body engine.
	
	\pagebreak
	\section{First steps}
		\subsection{PhysicsEngine}
		Each physic simulation needs one \textbf{PhysicsEngine}. It contains all \textbf{PhysicsEngineModules}, that are being used for the current simulation. Registering a module in the physics engine is as simple as:
		
		\begin{lstlisting}
			PhysicsEngineModule* myModule = new MyModule();
		
			PhysicsEngine engine;
			engine.registerModule(myModule, "myModule");
		\end{lstlisting}
	
		\subsection{PhysicsEngineModule}
		A \textbf{PhysicsEngineModule} is an abstract class, which allows the creation of new modules. A module contains an \textbf{IComputationInterface}, which can compute updates based on the data held by the module. This way The computation is separated from the data and therefore exchangeable. The function
		\begin{lstlisting}
			/**
			* \brief Get the computation interface of this module.
			* \return The computation interface.
			*/
			virtual IComputationInterface* getComputationInterface() const = 0;
		\end{lstlisting}
		is abstract, so that the module can directly communicate with the computation unit, which is derived from \textbf{IComputationInterface}. This prevents hacky casts inside implementations of \textbf{PhysicsEngineModule}.
		
		
		\subsection{Basic physics engine setup}
		In this section I guide you through the setup of a basic physics engine with particle and rigid body support.
		
		First we will create a particle module (ParticleWorld) with a default computation interface (DefaultParticleEngineCI), which is already provided by the library.
		\begin{lstlisting}
			r3::ParticleWorld* particleWorld;	
			particleWorld = new r3::ParticleWorld();
			
			const auto ci = new r3::DefaultParticleEngineCI(1000, 0, particleWorld);
			particleWorld->setComputationInterface(ci);
		\end{lstlisting}
		
		Then we will create a rigid body module (RigidBodyWorld) with a default computation interface (DefaultRigidBodyEngineCI), which is also provided by the library.
		\begin{lstlisting}
			r3::RigidBodyWorld* rigidBodyWorld;
			rigidBodyWorld = new r3::RigidBodyWorld();
			
			const auto ci = new r3::DefaultRigidBodyEngineCI();
			ci->setRigidBodyWorld(rigidBodyWorld);
			rigidBodyWorld->setComputationInterface(ci);
		\end{lstlisting}
		
		Now that we created our modules, we need to register them in the physics engine:
		\begin{lstlisting}
			PhysicsEngine physicsEngine;
		
			physicsEngine.registerModule(particleWorld, "particle");
			physicsEngine.registerModule(rigidBodyWorld, "rigid_body");
		\end{lstlisting}
		
		All that is left todo now, is to update our simulation by calling the \textbf{tick}-Funktion on the \textbf{PhysicsEngine}
		\begin{lstlisting}
			physicsEngine.tick(timeDelta);
		\end{lstlisting}
		Note: If timeDelta is too large, strange effects can occur, like objects travelling through walls, increasing oscillations, excessive acceleration etc.
	
	
	\pagebreak
	\section{Collision detection}
	One major part of this physics engine is the detection and resolution of collisions between rigid bodies. First off you will get to know the collision detection system. The task of this system is to find all points in 3D space, where collisions occur. Additionally it will save properties of a collision at every found point. The collision points and their properties will be used later on, to resolve these collisions.
		
		\subsection{Broad phase}
		The broad phase takes in a number of rigid bodies and outputs a number of \textbf{CollisionPairs}. The task of the broad phase is to eliminate collision pairs, which do not collide. The generated \textbf{CollisionPairs} are only potential contacts, which means that there can be false positives. There should never be false negatives (e.q. eliminated collision pairs, that actually collide).
		
		
		\subsection{Intermediate phase}
		An intermediate phase takes in a number of \textbf{CollisionPairs} and outputs a (probably) smaller number of \textbf{CollisionPairs}. An intermediate phase behaves just like a broad phase, with the only difference being that multiple intermediate phases can be concatenated.
		
		\subsection{Narrow phase}
		A narrow phase takes a number of \textbf{CollisionPairs} as input and outputs a number of contacts. These contacts are then used in the collision resolution later on.
		
			\subsubsection{Collision Algorithms}
			\begin{table}[ht]
				\begin{tabular}{|l || l | l | l |}
					\hline
					& \textbf{Box} & \textbf{Sphere} & \textbf{Plane}\\
					\hline
					\hline
					\textbf{Box} & Box-Box & Box-Sphere & Box-Plane\\
					\hline
					\textbf{Sphere} & Sphere-Box & Sphere-Sphere & Sphere-Plane\\
					\hline
					\textbf{Plane}& Plane-Box & Plane-Sphere & Plane-Plane\\
					\hline
				\end{tabular}
			\end{table}
		
		\subsection{Pipeline}
		\begin{minipage}{\textwidth}
			\begin{minipage}{0.45\textwidth}
				In figure \ref{fig:collisionDetectionPipeline} you can see the structure of the collision detection pipeline explained above. The \textbf{BroadphaseFilter} takes a set of rigid bodies as input and outputs a set of \textbf{CollisionPair}s.
				
				\noindent
				It might be more apparent now, that an intermediate phase filter is needed on top of a broadphase filter, since both receive different inputs.
			\end{minipage}\hfill
			\begin{minipage}[c]{0.45\textwidth}
				\begin{figure}[H]
					\centering
					\begin{tikzpicture}
					\node[draw=none] (Start) at (0, 0) {};
					\node[shape=rectangle, draw=black] (Broad) at (0,-2) 
					{Broadphase Filter};
					\node[shape=rectangle, draw=black] (Inter) at (0,-4) 
					{Intermediate Phase Filter};
					\node[shape=rectangle, draw=black] (Narrow) at (0,-6) 
					{Narrowphase Filter};
					\node[draw=none] (End) at (0, -8) {};
					
					\node[draw=none] (Loop0) at (1, -3.85) {};
					\node[draw=none] (Loop1) at (1, -2.5) {};
					\node[draw=none] (Loop2) at (2, -2.5) {};
					\node[draw=none] (Loop3) at (2, -3.85) {};
					
					\path[->](Start) edge node[left]{Rigid bodies}(Broad);
					\path[->](Broad) edge node[left]{Collision pairs}(Inter);
					\path[->](Inter) edge node[left]{Collision pairs}(Narrow);
					\path[->](Narrow) edge node[left]{Collision pairs}(End);
					
					\path[-](1, -3.75) edge node[left]{}(1, -2.5);
					\path[-](1, -2.5) edge node[right]{}(2, -2.5);
					\path[->](2, -2.5) edge node[right]{Collision pairs}(2, -3.75);
					
					\end{tikzpicture}
					\caption{Collision detection pipeline}
					\label{fig:collisionDetectionPipeline}
				\end{figure}
			\end{minipage}
		\end{minipage}
	
	\pagebreak
	\section{Particle Engine}
		The particle engine simulates the movement of particles.
	
		The main parts of the particle engine are:
		\begin{packed_itemize}
			\item Particle
			\item ParticleWorld
			\item ParticleForceRegistry
			\item ParticleContactGeneratorRegistry
			\item ParticleEngineCI
		\end{packed_itemize}
		
		\subsection{Particle}
		Particles are dimensionless points in space and can therefore not collide with other particles. A particle has a multitude of properties:
		
		\begin{tabular}[H]{r | l}
			Property & Range\\
			\hline
			position & $\mathbb{R}^3$\\
			velocity & $\mathbb{R}^3$\\
			acceleration & $\mathbb{R}^3$\\
			forceAccumulator & $\mathbb{R}^3$\\
			damping & $[0, 1]$\\
			inverseMass & $\mathbb{R}^+_0$\\
			isDead & $\{false, true\}$\\
		\end{tabular}
	
		Note: An inverseMass of 0 defines an object with infinite mass.
		
		\subsection{ParticleWorld}
		
		\subsection{ParticleForceRegistry}
		
		\subsection{ParticleContactGeneratorRegistry}
		
		\subsection{ParticleEngineCI}
		
		
		
	
	\pagebreak
	\section{Rigid Body Engine}
		The rigid body engine simulates the movement of rigid bodies.
		
		The main parts of the rigid body engine are:
		\begin{packed_itemize}
			\item RigidBody
			\item RigidBodyWorld
		\end{packed_itemize}
	
		\subsection{RigidBody}
		A rigid body is defined by following properties:
		
		\begin{tabular}[H]{r | l}
			Property & Range\\
			\hline
			position & $\mathbb{R}^3$\\
			rotation & $\mathbb{H}$\\
			velocity & $\mathbb{R}^3$\\
			acceleration & $\mathbb{R}^3$\\
			forceAccumulator & $\mathbb{R}^3$\\
			torqueAccumulator & $\mathbb{R}^3$\\
			linearDamping & $[0, 1]$\\
			angularDamping & $[0, 1]$\\
			inverseMass & $\mathbb{R}^+_0$\\
			isDead & $\{false, true\}$\\
			inverseInertiaTensor & $\mathbb{R}^{3 \times 3}$\\
		\end{tabular}
	
		\subsection{RigidBodyWorld}
	
	\pagebreak
	\section{Collision resolution}
	The collision resolution stage follows the collision detection stage. In this stage contacts are being resolved (eliminated) by moving the affected rigid bodies accordingly. 
		
		\subsection{Collision Resolver}
		Every \textbf{RigidBodyEngineCI} (CI = Computation Interface) contains one \textbf{CollisionResolver}. It holds a set of \textbf{ICollisionResolverFilter}. When there are collisions to resolve, it passes them through all previously registered filters. This pipeline can be seen in figure \ref{fig:collisionResolutionPipeline}.
		 
		\begin{figure}[H]
			\centering
			\begin{tikzpicture}
			\node[draw=none] (Start) at (0, -1) {};
			\node[shape=rectangle, draw=black] (Filter) at (5,-1) 
			{Collision Resolution Filter};
			\node[draw=none] (End) at (10, -1) {};
			
			\path[->](Start) edge node[above]{Contacts}(Filter);
			\path[->](Filter) edge node[above]{Contacts}(End);
			
			\path[-](3.5, -0.75) edge node[left]{}(3.5, 0);
			\path[-](3.5, 0) edge node[above]{Contacts}(6.5, 0);
			\path[->](6.5, 0) edge node[right]{}(6.5, -0.75);
			
			\end{tikzpicture}
			\caption{Collision resolution pipeline}
			\label{fig:collisionResolutionPipeline}
		\end{figure}
		 
		\subsection{Filter}
		A \textbf{ICollisionResolutionFilter} (as seen in listing \ref{lst:collisionResolutionFilter}) computes and applies changes to rigid bodies by using the contact data generated in the collision detection stage. 
		\begin{lstlisting}[caption={Collision resolution filter},captionpos=b, label=lst:collisionResolutionFilter]
			class R3D_DECLSPEC ICollisionResolutionFilter
			{
			public:
				virtual ~ICollisionResolutionFilter();
				
				/**
				* \brief Resolve given contacts.
				* \param collisionData The contacts to resolve.
				* \param timeDelta The time step of the current physics
				* update.
				*/
				virtual void resolve(CollisionData& collisionData,
				real timeDelta) = 0;
				
			protected:
				explicit ICollisionResolutionFilter();
			};
		\end{lstlisting}
		There already are two implementations of such a filter:
		\begin{packed_itemize}
			\item VelocityResolver
			\item InterpenetrationResolver
		\end{packed_itemize}
		The \textbf{InterpenetationResolver} changes the position and rotation of rigid bodies, so that they are no longer overlapping.
		
		The \textbf{VelocityResolver} changes the velocity of colliding rigid bodies, according to their contact normal, physics material and fricition before the impact.
		
		
		
	
	
	
	
	
	
	%\pagenumbering{alph}
	%\newpage
	%\appendix
	%\listoffigures
	%\listoftables
	
	% TODO: glossary
	
\end{document}


