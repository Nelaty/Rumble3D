\documentclass[12p, paper=a4, leqno, colorinlistoftodos]{article}
\usepackage{wrapfig}
\usepackage[utf8]{inputenc}
\usepackage[ngerman]{babel}
\usepackage{amsmath}
\usepackage{amsfonts} 
\usepackage{amssymb}
\usepackage{enumerate}
\usepackage{graphicx}
\usepackage{wrapfig}

\usepackage[parfill]{parskip}
\usepackage{subcaption}
\usepackage{fix-cm}
\usepackage{transparent}
\usepackage{color}
\usepackage[table]{xcolor}
\usepackage{tocloft, url}
\usepackage{hyperref}
\usepackage{etoolbox}
\usepackage{fancyhdr}
\usepackage[german]{fancyref}
\usepackage{lipsum}	
\usepackage{sectsty}
\usepackage{pdfpages}
\usepackage{tcolorbox}
\usepackage{todonotes}

\usepackage{enumitem}
\usepackage[bottom]{footmisc}

\usepackage{forest}
\usepackage{float}
\usepackage{longtable}
\usepackage[normalem]{ulem}
\usepackage{multirow}
\usepackage[font=small,labelfont=bf,tableposition=top]{caption}

\usepackage{tikz}
\usetikzlibrary{positioning,automata}

\usepackage{calc}
\usepackage{geometry}
\usepackage{listings,lstautogobble}
\usepackage{algorithm}
\usepackage{algorithmicx}
\usepackage[noend]{algpseudocode}

\usepackage{array}
\usepackage{booktabs}
\usepackage{xcolor,colortbl}
\usepackage{setspace}
\usepackage{titlesec}
\usepackage[nottoc,notlot,notlof,numbib]{tocbibind}

\usepackage{cite}


\hypersetup{
	colorlinks,
	linkcolor={black},
	citecolor={blue!50!black},
	urlcolor={blue!80!black}	
}

% BEGIN COLORS
\definecolor{CBlue}{RGB}{1,0,119}
\definecolor{CBlack}{rgb}{0.0,0.0,0.0}
\definecolor{CLightGrey}{rgb}{0.664,0.664,0.664}
\definecolor{LightOrange}{rgb}{1.0,0.9,0.63}
\definecolor{DarkOrange}{rgb}{1.0,0.8,0.22}
\definecolor{LightCyan}{rgb}{1.0,0.9,0.63}
\definecolor{CWhite}{RGB}{0,0,0}
\definecolor{CLink}{rgb}{0.5,0.0,0.0}

\newcommand{\CTitle}{CBlue}
% BEGIN Table row/column colors{102,217,239}
\definecolor{CEven0}{RGB}{208,238,244}
\definecolor{CUneven0}{RGB}{255,255,255}
\definecolor{CEven1}{rgb}{1.0,1.0,1.0}
\definecolor{CUneven1}{rgb}{1.0,1.0,1.0}
% END Table row/column colors
% END COLORS


% BEGIN NEWENVIRONMENTS
\newenvironment{packed_itemize}
{\begin{itemize}
		\setlength{\itemsep}{0pt}
		\setlength{\parskip}{0pt}
		\setlength{\parsep}{0pt}
	}{\end{itemize}}

\newenvironment{packed_description}
{\begin{description}
		\setlength{\itemsep}{0pt}
		\setlength{\parskip}{0pt}
		\setlength{\parsep}{0pt}}
	{\end{description}}

\newenvironment{packed_enumerate}
{\begin{enumerate}
		\setlength{\itemsep}{0pt}
		\setlength{\parskip}{0pt}
		\setlength{\parsep}{0pt}
	}{\end{enumerate}}

% END NEWENVIRONMENTS


% BEGIN NEWCOMMANDS
% tables
\newcommand{\tabularPaddingSmall}{\renewcommand{\arraystretch}{0.75}}
\newcommand{\tabularPaddingDefault}{\renewcommand{\arraystretch}{1}}
\newcommand{\tabularPaddinglarge}{\renewcommand{\arraystretch}{1.25}}
\newcommand{\tabularPaddingLarge}{\renewcommand{\arraystretch}{1.5}}
\newcommand{\tabularPaddingLARGE}{\renewcommand{\arraystretch}{2}}
\newcommand{\tabularPaddingBot}{\vspace{0.5cm}}

\newcommand{\tabitem}{~~\llap{\textbullet}~~}
\newcommand{\coloredHline}[1]{\arrayrulecolor{#1}\hline}
\newcommand{\minitab}[2][l]{\begin{tabular}{#1}#2\end{tabular}}

% quoting
\newcommand{\quoteSource}[2]{\glqq{#1}\grqq, \textit{#2}}
\newcommand{\quoteQuick}[1]{\glqq{#1}\grqq}
\newcommand{\quoteAuthor}[2]{\quoteQuick{#1}, von \textit{#2}}
\newcommand{\quoteCite}[2]{\quoteQuick{\textit{#1}}#2}
\newcommand{\srcSelf}{\\\text{Quelle: Eigene Darstellung}}
\newcommand{\citePage}[2]{\cite{#1} Seite: {#2}}
\newcommand{\citeEquation}[1]{\text{\hspace{1cm}{#1}}}

% paragraphs
\newcommand{\parTiny}{\vspace{2mm}\\}
\newcommand{\parSmall}{\\~\par}
\newcommand{\parNoIndent}{\\\noindent}
\newcommand{\parWrapfig}{\\\text{ }\\}

% math


% 
\newcommand{\emphFold}[1]{\textbf{#1}}

% page layout
\newcommand{\geometryNormal}{\newgeometry{top = 2cm, left=2.5cm,bottom=2cm, right = 4cm}}
\newcommand{\geometryToc}{\newgeometry{top = 3cm, left=3cm,bottom=3cm, right = 3cm}}

% todo notes
\newcommand{\todoLowp}[1]{\todo[color=green!40]{#1}}
\newcommand{\todoMedp}[1]{\todo[color=orange!40]{#1}}
\newcommand{\todoHighp}[1]{\todo[color=red!40]{#1}}
\newcommand{\todoFig}[1]{\missingfigure{#1}}

% titles
\colorlet{ctcolorchapternum}{black}

\newcommand\mysectionformatCore[1]{%
	\vspace{-3em}\parbox[b]{\dimexpr\textwidth-1em\relax}{\raggedright#1}}
\newcommand{\titleformatCore}
{
	\titleformat
	{\section}[display]%
	{\color{black}\Large\bfseries}%
	{\vspace{-18em}\raggedleft{%
			{\color{ctcolorchapternum}\fontsize{60}{60}{\selectfont\thesection}}%
		}\hspace{1em}%
	}%
	{0pt}%
	{\mysectionformatCore}%
	[{\vspace{-0.5em}%
		\rule{0.75\textwidth}{1pt}%
		\rule[-3pt]{0.25\textwidth}{4pt}}]
	
	\titleformat
	{\subsection}[block]%
	{\color{black}\large\bfseries}%
	{\thesubsection\text{ }}%
	{0pt}{}[]%
	
	\titleformat
	{\subsubsection}[block]%
	{\color{black}\normalsize\bfseries}%
	{\thesubsubsection\text{ }}%
	{0pt}{}[]%
	
	\titleformat{\paragraph}
	{\normalfont\normalsize\bfseries}{\theparagraph}{1em}{}
	\titlespacing*{\paragraph}
	{0pt}{3.25ex plus 1ex minus .2ex}{1.5ex plus .2ex}
}

\newcommand\mysectionformatAppendix[1]{#1}
\newcommand{\titleformatAppendix}
{
	\titleformat
	{\section}[display]%
	{\color{black}\Large\bfseries}%
	{}{0pt}{\mysectionformatAppendix}[]
}

% END NEWCOMMANDS

% BEGIN RENEW COMMANDS
% END RENEW COMMANDS

\newlistof{links}{lks}{List of Links}
\newcommand\externallink[1]{%
	\refstepcounter{links}%
	\footnote{\url{#1}}%
	\addcontentsline{lks}{links}{%
		\protect\numberline{\thelinks}%
		\protect\url{#1}}%
}
\newcommand\externallinkIL[1]{%
	\refstepcounter{links}%
	\addcontentsline{lks}{links}{%
		\protect\numberline{\thelinks}%
		\protect\url{#1}}%
}

\newcolumntype{L}[1]{>{\raggedleft\let\newline\\\arraybackslash\hspace{0pt}}m{#1}}
\newcolumntype{R}[1]{>{\raggedright\let\newline\\\arraybackslash\hspace{0pt}}m{#1}}
%\newcolumntype{C}[1]{>{\raggedcenter\let\newline\\\arraybackslash\hspace{0pt}}m{#1}}

\newcolumntype{C}[1]{>{\raggedcenter\hspace{0pt}}p{#1}}


\author{Matthias Elmar Gensheimer}
\title{Rumble3D Manual}
\date{\today}


% BEGIN HEADER
\newcommand{\headerNormal}
{
	\pagestyle{fancy}
	\fancyhf{}
	\lhead{\rightmark}
	\rhead{\thepage}
}

\newcommand{\headerEmpty}
{
	\fancyhf{}
	\renewcommand{\headrulewidth}{0pt}
	\lhead{}
	\rhead{}
}

\newcommand{\headerErklaerung}
{
	\pagestyle{fancy}
	\fancyhf{}
	\rhead{\thepage}
}
% END HEADER

% BEGIN FOOTER
\usepackage{scrlayer}
\DeclareNewLayer[
foreground,
foot,
hoffset=0pt,
width=\paperwidth,
contents={\parbox{\layerwidth}{\centering}}
]{PageMarkCentredToPage}
\RedeclarePageStyleByLayers{plain}{PageMarkCentredToPage}
% END FOOTER

% BEGIN TOC SETUP
\makeatletter
\patchcmd{\l@section}
{\hfil}
{\leaders\hbox{\normalfont$\m@th\mkern \@dotsep mu\hbox{.}\mkern \@dotsep mu$}\hfill}
{}{}
\makeatother
% END TOC SETUP

% BEGIN PAGE SETUP
\geometryNormal
\setlength{\extrarowheight}{3pt}
% END PAGE SETUP


\titleformatCore
\headerNormal

\begin{document}
	\pagenumbering{Roman} 
	
	\lstset{language=C++,
		keywordstyle=\color{blue},
		basicstyle=\ttfamily,
		commentstyle=\ttfamily\itshape\color{gray},
		stringstyle=\ttfamily,
		showstringspaces=false,
		numbers=left,
		numberstyle=\small,
		breaklines=true,
		frameround=ffff,
		rulecolor=\color{black},
		frame=single,
		captionpos=b,
		autogobble=true
	}
	
	\begin{titlepage}
		\begin{flushright}
			\includegraphics[width=0.45\textwidth]{resources/hs_kempten_logo}
		\end{flushright}
		\begin{center}
			\topskip0pt
			\vspace*{\fill}
			\LARGE\textbf{Rumble3D User Manual}\\		
			\LARGE{A 3D physics library}\\

			\vfill
			\Large{\textcopyright 2018 Matthias Gensheimer}\\
			\Large{All Rights Reserved.}
		\end{center}
		
	\end{titlepage}
	
	% Add an empty page
	\mbox{}
	\thispagestyle{empty}
	\newpage
	
	\pagebreak
	
	\geometryNormal
	\tableofcontents
	\geometryNormal
	\setstretch{1.30}
	
	\pagenumbering{arabic} 
	\section{Introduction}
	Rumble3D is a 3D physics library. Its core features are:
	\begin{itemize}
		\item Particle simulation
		\item Rigid body simulation
		\item Force generators
		\item Collision detection and resolution
	\end{itemize}
	Due to the engine being made up of physic modules, it is fully extensible.

	This manual will guide you through your first steps setting up the physics engine. It will explain the main parts of using the particle and rigid body engine aswell as the collision detection and resolution pipeline used in the rigid body engine.
	
	\pagebreak
	\section{First steps}
		\subsection{PhysicsEngine}
		Each physic simulation needs one \textbf{PhysicsEngine}. It contains all \textbf{PhysicsEngineModules}, that are being used for the current simulation. Registering a module in the physics engine is as simple as:
		
		\begin{lstlisting}
			PhysicsEngineModule* myModule = new MyModule();
		
			PhysicsEngine engine;
			engine.registerModule(myModule, "myModule");
		\end{lstlisting}
	
		\subsection{PhysicsEngineModule}
		A \textbf{PhysicsEngineModule} is an abstract class, which allows the creation of new modules. A module contains an \textbf{IComputationInterface}, which can compute updates based on the data held by the module. This way The computation is separated from the data and therefore exchangeable. The function
		\begin{lstlisting}
			/**
			* \brief Get the computation interface of this module.
			* \return The computation interface.
			*/
			virtual IComputationInterface* getComputationInterface() const = 0;
		\end{lstlisting}
		is abstract, so that the module can directly communicate with the computation unit, which is derived from \textbf{IComputationInterface}. This prevents hacky casts inside implementations of \textbf{PhysicsEngineModule}.
		
		
		\subsection{Basic physics engine setup}
		In this section I guide you through the setup of a basic physics engine with particle and rigid body support.
		
		First we will create a particle module (ParticleWorld) with a default computation interface (DefaultParticleEngineCI), which is already provided by the library.
		\begin{lstlisting}
			r3::ParticleWorld* particleWorld;	
			particleWorld = new r3::ParticleWorld();
			
			const auto ci = new r3::DefaultParticleEngineCI(1000, 0, particleWorld);
			particleWorld->setComputationInterface(ci);
		\end{lstlisting}
		
		Then we will create a rigid body module (RigidBodyWorld) with a default computation interface (DefaultRigidBodyEngineCI), which is also provided by the library.
		\begin{lstlisting}
			r3::RigidBodyWorld* rigidBodyWorld;
			rigidBodyWorld = new r3::RigidBodyWorld();
			
			const auto ci = new r3::DefaultRigidBodyEngineCI();
			ci->setRigidBodyWorld(rigidBodyWorld);
			rigidBodyWorld->setComputationInterface(ci);
		\end{lstlisting}
		
		Now that we created our modules, we need to register them in the physics engine:
		\begin{lstlisting}
			PhysicsEngine physicsEngine;
		
			physicsEngine.registerModule(particleWorld, "particle");
			physicsEngine.registerModule(rigidBodyWorld, "rigid_body");
		\end{lstlisting}
		
		All that is left todo now, is to update our simulation by calling the \textbf{tick}-Funktion on the \textbf{PhysicsEngine}
		\begin{lstlisting}
			physicsEngine.tick(timeDelta);
		\end{lstlisting}
		Note: If timeDelta is too large, strange effects can occur, like objects travelling through walls, increasing oscillations, excessive acceleration etc.
	
	
	\pagebreak
	\section{Collision detection}
	One major part of this physics engine is the detection and resolution of collisions between rigid bodies. First off you will get to know the collision detection system. The task of this system is to find all points in 3D space, where collisions occur. Additionally it will save properties of a collision at every found point. The collision points and their properties will be used later on, to resolve these collisions.
		
		\subsection{Broad phase}
		The broad phase takes in a number of rigid bodies and outputs a number of \textbf{CollisionPairs}. The task of the broad phase is to eliminate collision pairs, which do not collide. The generated \textbf{CollisionPairs} are only potential contacts, which means that there can be false positives. There should never be false negatives (e.q. eliminated collision pairs, that actually collide).
		
		
		\subsection{Intermediate phase}
		An intermediate phase takes in a number of \textbf{CollisionPairs} and outputs a (probably) smaller number of \textbf{CollisionPairs}. An intermediate phase behaves just like a broad phase, with the only difference being that multiple intermediate phases can be concatenated.
		
		\subsection{Narrow phase}
		A narrow phase takes a number of \textbf{CollisionPairs} as input and outputs a number of contacts. These contacts are then used in the collision resolution later on.
		
			\subsubsection{Collision Algorithms}
			\begin{table}[ht]
				\begin{tabular}{|l || l | l | l |}
					\hline
					& \textbf{Box} & \textbf{Sphere} & \textbf{Plane}\\
					\hline
					\hline
					\textbf{Box} & Box-Box & Box-Sphere & Box-Plane\\
					\hline
					\textbf{Sphere} & Sphere-Box & Sphere-Sphere & Sphere-Plane\\
					\hline
					\textbf{Plane}& Plane-Box & Plane-Sphere & Plane-Plane\\
					\hline
				\end{tabular}
			\end{table}
		
		\subsection{Pipeline}
		\begin{minipage}{\textwidth}
			\begin{minipage}{0.45\textwidth}
				In figure \ref{fig:collisionDetectionPipeline} you can see the structure of the collision detection pipeline explained above. The \textbf{BroadphaseFilter} takes a set of rigid bodies as input and outputs a set of \textbf{CollisionPair}s.
				
				\noindent
				It might be more apparent now, that an intermediate phase filter is needed on top of a broadphase filter, since both receive different inputs.
			\end{minipage}\hfill
			\begin{minipage}[c]{0.45\textwidth}
				\begin{figure}[H]
					\centering
					\begin{tikzpicture}
					\node[draw=none] (Start) at (0, 0) {};
					\node[shape=rectangle, draw=black] (Broad) at (0,-2) 
					{Broadphase Filter};
					\node[shape=rectangle, draw=black] (Inter) at (0,-4) 
					{Intermediate Phase Filter};
					\node[shape=rectangle, draw=black] (Narrow) at (0,-6) 
					{Narrowphase Filter};
					\node[draw=none] (End) at (0, -8) {};
					
					\node[draw=none] (Loop0) at (1, -3.85) {};
					\node[draw=none] (Loop1) at (1, -2.5) {};
					\node[draw=none] (Loop2) at (2, -2.5) {};
					\node[draw=none] (Loop3) at (2, -3.85) {};
					
					\path[->](Start) edge node[left]{Rigid bodies}(Broad);
					\path[->](Broad) edge node[left]{Collision pairs}(Inter);
					\path[->](Inter) edge node[left]{Collision pairs}(Narrow);
					\path[->](Narrow) edge node[left]{Collision pairs}(End);
					
					\path[-](1, -3.75) edge node[left]{}(1, -2.5);
					\path[-](1, -2.5) edge node[right]{}(2, -2.5);
					\path[->](2, -2.5) edge node[right]{Collision pairs}(2, -3.75);
					
					\end{tikzpicture}
					\caption{Collision detection pipeline}
					\label{fig:collisionDetectionPipeline}
				\end{figure}
			\end{minipage}
		\end{minipage}
	
	\pagebreak
	\section{Computation Interface}
		This physics engine decouples data from computation. Each \textbf{PhysicsEngineModule} provides method, which returns an \textbf{IComputationInterface}. This interface consists of 4 methods:
		\begin{packed_itemize}
			\item void onBegin()
			\item void step(real timeDelta)
			\item void integrate(real timeDelta)
			\item void onEnd() 
		\end{packed_itemize}
		In each iteration, the \textbf{PhysicsEngine} will go over every \textbf{PhysicsEngineModule}, get their computation interfaces (CI) and call
		\begin{packed_enumerate}
			\item onBegin() on all CIs
			\item then step() on all CIs
			\item then integrate() on all CIs
			\item and finally onEnd() on all CIs
		\end{packed_enumerate}
		This decoupling allows the usage of multiple computation interfaces for multiple task, such as:
		\begin{packed_itemize}
			\item Very accurate, but computationally expensive offline calculations
			\item Real time simulations
			\item CPU and/or GPU simulations
		\end{packed_itemize}
	
	\pagebreak
	\section{Particle Engine}
		The particle engine simulates the movement of particles.
	
		The main parts of the particle engine are:
		\begin{packed_itemize}
			\item Particle
			\item ParticleWorld
			\item ParticleForceRegistry
			\item ParticleContactGeneratorRegistry
			\item ParticleEngineCI
		\end{packed_itemize}
		
		\subsection{Particle}
		Particles are dimensionless points in space and can therefore not collide with other particles. A particle has a multitude of properties:
		
		\begin{tabular}[H]{r | l}
			Property & Range\\
			\hline
			position & $\mathbb{R}^3$\\
			velocity & $\mathbb{R}^3$\\
			acceleration & $\mathbb{R}^3$\\
			forceAccumulator & $\mathbb{R}^3$\\
			damping & $[0, 1]$\\
			inverseMass & $\mathbb{R}^+_0$\\
			isDead & $\{false, true\}$\\
		\end{tabular}
	
		Note: An inverseMass of 0 defines an object with infinite mass.
		
		\subsection{ParticleWorld}
		The \textbf{ParticleWorld} consists of
		\begin{packed_itemize}
			\item A container of particles
			\item A force registry
			\item A contact generator regsitry
			\item A particle computation interface
		\end{packed_itemize}
		Particles can be registered and unregister. Only particles, which are registered, will receive updates.
		
		\subsection{ParticleForceRegistry}
		The force registry contains Particle-ParticleForceGenerator entry-pairs. A force generator will add forces to the particle, which it is paired up with, in every update step. A force generator can be paired up with multiple particles and a particle can be influenced by multiple force generators.
		
		\subsection{ParticleContactGeneratorRegistry}
		The ParticleContactGeneratorRegistry works similarly to the ParticleForceRegistry. Except instead of having Particle-ParticleForceGenerator pairs, we now have Particle-ParticleContactGenerator pairs.
		
		A \textbf{ParticleContactGenerator} doesn't add forces to particles, but creates \textbf{ParticleContact}s if necessary. I.e. two particles, which are connected by a \textbf{ParticleRod} should always have the same predefined distance. If that is not the case $\rightarrow$ generate a contact.
		
		Resolving those contacts is done by the \textbf{ParticleContactResolver} and is part of the \textbf{ParticleEngineCI}.
		
		\subsection{ParticleEngineCI}
		The \textbf{ParticleEngineCI} (CI: computation interface) is responsible for transforming the data in a \textbf{ParticleWorld}. This means:
		\begin{packed_itemize}
			\item Calculating particle forces by using the force registry
			\item Integrating these forces
			\item Detect contacts and resolve them by using the ParticleContactResolver
		\end{packed_itemize}	
		Since ParticleEngineCI is only an abstract class, there needs to be an implementation for it. There is already a default implementation of this computation interface called \textbf{DefaultParticleEngineCI}.		
	
	\pagebreak
	\section{Rigid Body Engine}
		The rigid body engine simulates the movement of rigid bodies.
		
		The main parts of the rigid body engine are:
		\begin{packed_itemize}
			\item RigidBody
			\item RigidBodyWorld
		\end{packed_itemize}
	
		\subsection{RigidBody}
		A rigid body is defined by following properties:
		
		\begin{tabular}[H]{r | l}
			Property & Range\\
			\hline
			position & $\mathbb{R}^3$\\
			rotation & $\mathbb{H}$\\
			velocity & $\mathbb{R}^3$\\
			acceleration & $\mathbb{R}^3$\\
			forceAccumulator & $\mathbb{R}^3$\\
			torqueAccumulator & $\mathbb{R}^3$\\
			linearDamping & $[0, 1]$\\
			angularDamping & $[0, 1]$\\
			inverseMass & $\mathbb{R}^+_0$\\
			isDead & $\{false, true\}$\\
			inverseInertiaTensor & $\mathbb{R}^{3 \times 3}$\\
		\end{tabular}
	
		\subsection{RigidBodyWorld}
		The \textbf{RigidBodyWorld} consists of:
		\begin{packed_itemize}
			\item A container of rigid bodies
			\item A \textbf{ForceRegistry}
			\item A \textbf{RigidBodyCI}
		\end{packed_itemize}
		Rigid bodies can be registered and unregistered.
		
		\subsection{ForceRegistry}
		It holds a set of RigidBody-ForceGenerator pairs. The force generators are used to act forces onto the rigid bodies they are coupled with.
		
		\subsection{RigidBodyCI}
		The \textbf{RigidBodyCI} uses the data in a \textbf{RigidBodyWorld} to transform it. This means:
		\begin{packed_itemize}
			\item Calculating forces by using the \textbf{ForceRegistry}
			\item Detecting contacts by using the \textbf{ContactDetector}
			\item Resolving those contacts by using the \textbf{CollisionResolver}
			\item Integrating the accumulated forces
		\end{packed_itemize}
		The library already provides an implementation of such a RigidBodyCI, which is called \textbf{DefaultRigidBodyCI}.
		
	\pagebreak
	\section{Collision resolution}
	The collision resolution stage follows the collision detection stage. In this stage contacts are being resolved (eliminated) by moving the affected rigid bodies accordingly. 
		
		\subsection{Collision Resolver}
		Every \textbf{RigidBodyEngineCI} (CI = Computation Interface) contains one \textbf{CollisionResolver}. It holds a set of \textbf{ICollisionResolverFilter}. When there are collisions to resolve, it passes them through all previously registered filters. This pipeline can be seen in figure \ref{fig:collisionResolutionPipeline}.
		 
		\begin{figure}[H]
			\centering
			\begin{tikzpicture}
			\node[draw=none] (Start) at (0, -1) {};
			\node[shape=rectangle, draw=black] (Filter) at (5,-1) 
			{Collision Resolution Filter};
			\node[draw=none] (End) at (10, -1) {};
			
			\path[->](Start) edge node[above]{Contacts}(Filter);
			\path[->](Filter) edge node[above]{Contacts}(End);
			
			\path[-](3.5, -0.75) edge node[left]{}(3.5, 0);
			\path[-](3.5, 0) edge node[above]{Contacts}(6.5, 0);
			\path[->](6.5, 0) edge node[right]{}(6.5, -0.75);
			
			\end{tikzpicture}
			\caption{Collision resolution pipeline}
			\label{fig:collisionResolutionPipeline}
		\end{figure}
		 
		\subsection{Filter}
		A \textbf{ICollisionResolutionFilter} (as seen in listing \ref{lst:collisionResolutionFilter}) computes and applies changes to rigid bodies by using the contact data generated in the collision detection stage. 
		\begin{lstlisting}[caption={Collision resolution filter},captionpos=b, label=lst:collisionResolutionFilter]
			class R3D_DECLSPEC ICollisionResolutionFilter
			{
			public:
				virtual ~ICollisionResolutionFilter();
				
				/**
				* \brief Resolve given contacts.
				* \param collisionData The contacts to resolve.
				* \param timeDelta The time step of the current physics
				* update.
				*/
				virtual void resolve(CollisionData& collisionData,
				real timeDelta) = 0;
				
			protected:
				explicit ICollisionResolutionFilter();
			};
		\end{lstlisting}
		There already are two implementations of such a filter:
		\begin{packed_itemize}
			\item VelocityResolver
			\item InterpenetrationResolver
		\end{packed_itemize}
		The \textbf{InterpenetationResolver} changes the position and rotation of rigid bodies, so that they are no longer overlapping.
		
		The \textbf{VelocityResolver} changes the velocity of colliding rigid bodies, according to their contact normal, physics material and fricition before the impact.
		
		
		
	
	
	
	
	
	
	%\pagenumbering{alph}
	%\newpage
	%\appendix
	%\listoffigures
	%\listoftables
	
	% TODO: glossary
	
\end{document}


